package Lesson2;

import java.util.Arrays;

public class Lesson2 {
    public static void main(String[] args) {

        System.out.println("1. Задать целочисленный массив, состоящий из элементов 0 и 1.\nНапример: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ].\nС помощью цикла и условия заменить 0 на 1, 1 на 0;");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        InvertArray();
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("2. Задать пустой целочисленный массив размером 8.\nС помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        ArraySize8();
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ],\nпройти по нему циклом, и числа, меньшие 6, умножить на 2;");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        ArrayLarge6Multi2();
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое),\nи с помощью цикла(-ов) заполнить его диагональные элементы единицами;");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        arrayDiagonal();
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("5. Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        miniMaxArray();
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("6. Написать метод, в который передается не пустой одномерный целочисленный массив,\nметод должен вернуть true если в массиве есть место, в котором сумма левой и правой части массива равны. ");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        int[]inputMirrorArray={1,1,1,2,1};//Объявляем и инициализируем массив, который будем передавать в метод
        System.out.println("Передаём в метод массив:");
        System.out.println(Arrays.toString(inputMirrorArray));
        System.out.println("Результат работы метода: "+mirrorSumArray(inputMirrorArray));
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("7. Написать метод, которому на вход подается одномерный массив и число n (может быть положительным или отрицательным),\nпри этом метод должен сместить все элементы массива на n позиций.\nНельзя пользоваться вспомогательными массивами.");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        int[]inputOffsetArray={1,2,3,4,5};//Объявляем и инициализируем массив, который будем передавать в метод
        System.out.println("Передаём в метод массив:");
        System.out.println(Arrays.toString(inputOffsetArray));
        int offset=8;
        System.out.println("Смещение n: "+offset);
        System.out.println("Результат работы метода:");
        System.out.println(Arrays.toString(offsetArrayN(inputOffsetArray,offset)));
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями

        System.out.println("Дополнительное: Составить алгоритм заполнения матрицы по спирали с увеличением каждого последующего элемента на 1.\nЗаполнить таким образом матрицу 5*7");
        System.out.println();//Для отступа между постановкой задачи и выводом результата
        int line=5;//Объявляем и инициализируем необходимое количество строк будущего массива
        int column=7;//Объявляем и инициализируем необходимое количество столбцов будущего массива
        System.out.println("Создадим матрицу, заполненную по спирали, размера "+line+"х"+column);
        System.out.println("Результат работы метода:");
        int[][]matrixSpiral=spiralArray(line-1,column-1);
        /*Мне удобно передавать в массив именно размерности-1, так как максимальные номера строк и столбцов нужны будут
        гораздо чаще, чем сами значения размерностей
         */
        for (int i = 0; i < line; i++) {
            for (int j=0;j<column;j++) {
                System.out.print (matrixSpiral [i][j]+"\t");
            }
            System.out.println();
        }
        System.out.println("-----------------------------------------------");//Для разделения между разными заданиями
    }

    /*1.Задать целочисленный массив, состоящий из элементов 0 и 1.
   Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;
   */
    static void InvertArray() {
        int[] array = {1, 1, 0, 0, 1, 0, 1, 1, 0, 0}; //Задаём целочисленный массив из 10ти элементов
        //Выведем наш массив на экран для удобства проверки
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(array));
        //Теперь заменим 0 на 1, 1 на 0
        for (int i = 0; i < 10; i++) {
            array[i]=(array[i] == 1)?0:1;
        }
        //И выведем на экран то, что у нас в итоге получилось
        System.out.println("Инвертированный массив:");
        System.out.println(Arrays.toString(array));
    }

    /*2.Задать пустой целочисленный массив размером 8.
 С помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;
 */
    static void ArraySize8() {
        int[] array = new int[8];//Задаем пустой целочисленный массив размером 8
        //Элементы заполняем в цикле в прогрессии с периодом 3
        for (int i = 0; i < array.length; i++) {
            array[i] = i* 3;
        }
        //И выведем на экран то, что у нас в итоге получилось
        System.out.println("Итоговый массив:");
        System.out.println(Arrays.toString(array));
    }

    /*3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ],
 пройти по нему циклом, и числа, меньшие 6, умножить на 2;
 */
    static void ArrayLarge6Multi2() {
        int[] array = {1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1};//Задаём массив
        //Выведем наш массив на экран для удобства проверки
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(array));
        //теперь умножаем на 2 числа, меньшие 6
        for (int i = 0; i < 12; i++) {
            if (array[i] < 6) array[i] *= 2;
        }
        //И распечатываем результат
        System.out.println("Итоговый массив:");
        System.out.println(Arrays.toString(array));
    }

    /*4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое),
    и с помощью цикла(-ов) заполнить его диагональные элементы единицами;
     */
    static void arrayDiagonal() {
        //создаем квадратную матрицу, например, 5х5
        int[][] array = new int[5][5];
        /*Помним, что int, как и все целочисленные типы, инициализируется нулём по умолчанию,
        поэтому отдельный массив на заполнение нулями писать не имеет смысла.
        Далее определяемся, что для квадратной матрицы первая диагналь - это когда номер строки равен номеру столбца,
        а вторая диагональ - это когда сумма номеров строки и столбца равна размерности-1 (минус 1, так как начало с нуля),
        то есть, в общем случае для неизвестной размерности условие такое: array[i].length-1==i+j. Тогда j=array[i].length-1-i
        У нас размерность известна, поэтому я не буду использовать length, чтобы не усложнять. Заполняем диагонали единичками,
        в соответствии с вышеприведенными условиями
        */
        for (int i = 0; i < 5; i++) {
            array[i][i]=1;
            array[i][4-i]=1;
        }
        //И распечатываем результат
        for (int i = 0; i < 5; i++) {
            System.out.println(Arrays.toString(array[i]));
        }
    }

    //5. Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);
    static void miniMaxArray() {
        //Создаём одномерный массив
        int[] array = {2, 5, 3, 12, 21, 4, 5, 2, 4, 8, 9, 5};
        //Выведем наш массив на экран для удобства проверки
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(array));
        int temporMin = array[0];//Задаём временный минимум равным первому элементу массива
        int temporMax = array[0];//Задаём временный минимум равным первому элементу массива
        /*Далее будем в цикле сравнивать содержимое temporMin и temporMax с элементами массива поочерёдно.
        Если элемент массива меньше temporMin, то записываем его в temporMin, если элемент массива больше
        temporMax, то записываем его в temporMax. Таким образом в temporMin и temporMax в итоге общего перебора
        окажется самое маленькое и самое большое число массива соответствекнно. Цикл сразу начнём с 1го элемента,
        так как нулевой проверять бессмысленно
         */
        for (int i = 1; i < 12; i++) {
            if (array[i] < temporMin) temporMin = array[i];
            if (array[i] > temporMax) temporMax = array[i];
        }
        //Выводим результат
        System.out.println("Минимальный элемент: " + temporMin);
        System.out.println("Максимальный элемент: " + temporMax);
    }

    /*6. Написать метод, в который передается не пустой одномерный целочисленный массив,
    метод должен вернуть true если в массиве есть место, в котором сумма левой и правой части массива равны.
     */
    static boolean mirrorSumArray(int[] array) {
        boolean rezult=false;//булева переменная для записи результата
        int tempSumLeft=0;//Переменная для суммы левой части
        for (int i=0;i<array.length;i++){
            tempSumLeft+=array[i];
            int tempSumRight=0;//Переменная для суммы правой части
            for (int j=i+1;j<array.length;j++){
                tempSumRight+=array[j];
            }
            if (tempSumLeft==tempSumRight){//Если суммы левой и правой частей равны, то передаём в результат истину и прерываем цикл
                rezult=true;
                break;
            }
        }
        return rezult;
    }

    /*7. *Написать метод, которому на вход подается одномерный массив и число n (может быть положительным или отрицательным),
    при этом метод должен сместить все элементы массива на n позиций. Нельзя пользоваться вспомогательными массивами.
     */
    static int[] offsetArrayN (int[] array,int n) {
        /* Для начала немного оптимизируем n: если он больше длины массива, оставим только остаток от этой длины,
        чтобы наши будущие циклы не крутились фактически вхолостую
         */
        if (Math.abs(n)>array.length) n%=array.length;
        //Будем n по модулю раз повторять одиночный сдвиг в нужную сторону
        int bufferVar;//Переменная для хранения крайнего элемента массива (вылетающего при одиночном сдвиге)
        if(n>0){//Если n положительное, то двигаем вправо
           for(int numOffset=1;numOffset<=n;numOffset++) {//повторяем сдвиг на один элемент |n| число раз
               bufferVar = array[array.length - 1];
               for (int i = array.length - 1; i >= 1; i--) {//сдвигаем на 1 элемент вправо
                   array[i] = array[i - 1];
               }
               array[0] = bufferVar;
           }
        }else if (n==0){//Если n равно нулю, то двигать не нужно
            System.out.println("Массив сдвигать не нужно");
        }else{//Если n отрицательное, то двигаем влево
            for(int numOffset=n;numOffset<0;numOffset++) {//повторяем сдвиг на один элемент |n| число раз
                bufferVar = array[0];
                for (int i = 0; i < array.length - 1; i++) {//сдвигаем на 1 элемент влево
                    array[i] = array[i + 1];
                }
                array[array.length - 1] = bufferVar;
            }
        }
        return array;
    }

    /*Дополнительная задача:
    Составить алгоритм заполнения матрицы по спирали с увеличением каждого последующего элемента на 1.
    Заполнить таким образом матрицу 5*7
     */
    static int [][] spiralArray (int maxNumberLine, int maxNumberColumn) {
        int [][]integerSpiralArray=new int[maxNumberLine+1][maxNumberColumn+1];//Это и будет наша спиральная матрица
        /*Покрутив процесс заполнения, понимаем закономерность. Существует определённый цикл:
        1. заполнение вдоль первой строки от первого до поледнего элемента;
        2. отсекание первой строки как уже заполненной;
        2. заполнение вдоль последнего столбца от первого до последнего элемента (учитывая, что верхний элемент
           столбца уже отсечён);
        3. отсекание последнего столбца как уже заполненного;
        4. заполнение вдоль последней строки от последнего до первого элемента;
        5. отсекание последней строки как уже заполненной;
        6. заполнение вдоль первого столбца от последнего до первого элемента;
        7. отсекание первого столбца как уже заполненного.
        А если кратко и условно (если принять, что L = maxNumberLine, N=maxNumberColumn):
        строка 1 - вперёд. Отсекаем 1ую строку
        столбец N - вперёд. Отсекаем Nый столбец
        строка L - назад. Отсекаем Lую строку
        столбец 1 - назад. Отсекаем 1ый столбец
       Получается 4 процедуры, которые можно зациклить. А отсечение уже заполненных строк и столбцов реализуем с помощью
       итерационной переменной этого цикла.
         */
        int value=1;//Для хранения значений элементов массива
        int i=0;//Переменная, с помощью которой мы будем отсекать из заполнения ненужные строки и столбцы
        while (true) {
            for (int j = i; j <= (maxNumberColumn - i); j++) {//Это цикл для "строка 1 - вперёд."
                integerSpiralArray[i][j] = value;
                value++;
            }
            /* Далее идёт условие выхода из цикла: если мы всё заполнили, то выходим
            Проверять нужно после каждой из наших четырёх процедур, так как в зависимости от размерности заполнение
            может произойти после любой из них
             */
            if((value)>((maxNumberLine+1)*(maxNumberColumn+1))) break;

            for (int j = i + 1; j <= (maxNumberLine - i); j++) {//Это цикл для "столбец N - вперёд."
                integerSpiralArray[j][maxNumberColumn - i] = value;
                value++;
            }
            if((value)>((maxNumberLine+1)*(maxNumberColumn+1))) break;

            for (int j = maxNumberColumn - i - 1; j >= i; j--) {//Это цикл для "строка L - назад."
                integerSpiralArray[maxNumberLine - i][j] = value;
                value++;
            }
            if((value)>((maxNumberLine+1)*(maxNumberColumn+1))) break;

            for (int j = maxNumberLine - i - 1; j >= i + 1; j--) {//Это цикл для "столбец 1 - назад."
                integerSpiralArray[j][i] = value;
                value++;
            }
            if((value)>((maxNumberLine+1)*(maxNumberColumn+1))) break;

            i++;//Увеличиваем итерационную переменную, чтобы зациклить 4 повторяющихся процедуры
        }
        return integerSpiralArray;
    }

}
